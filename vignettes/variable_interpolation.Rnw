% \VignetteIndexEntry{Simple variable interpolation in R}
% \VignetteDepends{GetoptLong}
% \VignetteKeywords{variable interpolation}
% \VignettePackage{GetoptLong}

\documentclass{article}

\title{Simple variable interpolation in R}

\author{Zuguang Gu {\tt <z.gu@dkfz.de>}}
\usepackage[margin=1in, a4paper]{geometry}

\usepackage{Sweave}
\usepackage{hyperref}
\begin{document}

\maketitle 

There are several ways to construct strings in {\it R} such as {\tt paste}. However,
when the string which is going to be constructed is so complicated, using {\tt paste}
will be a nightmare. For example, we want to put some parameters as title in a plot.

<<eval = TRUE, include = TRUE, echo = TRUE>>==
region = c(1, 2)
value = 4
name = "name"
str = paste("region = (", region[1], ", ", region[2], "), value = ", value, 
            ", name = '", name, "'", sep = "")
cat(str, "\n")
@

As you can see, it is hard to read and very easy to make mistakes.

In {\it Perl}, we always use variable interpolation to construct complicated texts in 
which variables are started with special marks, and variables will be replaces with
there real values. In this package, we aim to implement variable interpolation in {\it R}.
The idea is rather simple: use special marks to identify variables in a string and then
replace with their values. The function is {\tt qq} which is named from same name
subroutine in {\it Perl} (It stands for double quote). Using variable interpolation, above
example can be written as:

<<eval = TRUE, include = TRUE, echo = TRUE>>==
library(GetoptLong)

str = qq("region = (@{region[1]}, @{region[2]}), value = @{value}, name = '@{name}'")
cat(str)
@

Or use the short cut function {\tt qqcat}:

<<eval = TRUE, include = TRUE, echo = TRUE>>==
library(GetoptLong)

qqcat("region = (@{region[1]}, @{region[2]}), value = @{value}, name = '@{name}'")
@

\section{Code patterns}
As you can see in above exmaple, {\tt @\{\}} is used to mark variables. Later these marks
will be replaced with their real values.

The marking code pattern can be any kind. But you should make sure it is easy to tell the difference
from other part of string. You can set your code pattern as an argument in {\tt qq}:

<<eval = TRUE, include = TRUE, echo = TRUE>>==
x = 1
qqcat("x = #{x}", code.pattern = "#\\{CODE\\}")
@

Or set in {\tt options} as a global setting:

<<eval = FALSE, echo = TRUE>>=
options(code.pattern = "#\\{CODE\\}")
@

As you can guess, in {\tt \#\textbackslash\textbackslash\{CODE\textbackslash\textbackslash\}}, {\tt CODE} will be replaced with {\tt .*?} to construct a regular
expression to match variables in the string. So if your {\tt code.pattern} contains special characters,
make sure to escape them. Some candidate {\tt code.pattern}s are:

<<eval = FALSE, echo = TRUE>>=
code.pattern = "@\\{CODE\\}"    # default style
code.pattern = "@\\[CODE\\]"
code.pattern = "@\\(CODE\\)"
code.pattern = "%\\{CODE\\}"
code.pattern = "%\\[CODE\\]"
code.pattern = "%\\(CODE\\)"
code.pattern = "\\$\\{CODE\\}"
code.pattern = "\\$\\[CODE\\]"
code.pattern = "\\$\\(CODE\\)"
code.pattern = "#\\{CODE\\}"
code.pattern = "#\\[CODE\\]"
code.pattern = "#\\(CODE\\)"
code.pattern = "\\[%CODE%\\]"  # Template (Perl module) style :)
@

Since we just replace {\tt CODE} to {\tt .*?}, the function will only match to the first right brace. So,
for example, you are using {\tt @\textbackslash\textbackslash[CODE\textbackslash\textbackslash]} and your string is {\tt "@[a[1]]"}, it will not successfully
extract the right variable name which is only {\tt a[1}. In such condition, you should use other styles
that do not contain {\tt []}. Finally, a more safe code pattern style that you do not need to worry about
braces stuff:

<<eval = FALSE, echo = TRUE>>==
code.pattern = "`CODE`"
@

\section{Where to look for variables}

It will first look up in the envoking environment, then through searching path. Users can also pass values of variables
as a list like:

<<eval = TRUE, include = TRUE, echo = TRUE>>==
x = 1
y = 2
qqcat("x = @{x}, y = @{y}", env = list(x = "a", y = "b"))
@

\section{What if variables return non-vector values}

{\tt qq} only allows variables to return vectors. The whole string will be interpolated repeatedly according to longest vectors.
Note {\tt qq} only returns a interpolated string which has length of 1.

<<eval = TRUE, include = TRUE, echo = TRUE>>==
x = 1:6
qqcat("@{x} is an @{ifelse(x %% 2, 'odd', 'even')} number.\n")


y = c("a", "b")
z = c("A", "B", "C", "D", "E")
qqcat("@{x}, @{y}, @{z}\n")
@

This feature is especially useful if you want to generate a HTML table:

<<eval = TRUE, include = TRUE, echo = TRUE>>==
name = letters[1:4]
value = 1:4
qqcat("<tr><td>@{name}</td><td>@{value}</td><tr>\n")
@

\section{You can also interpolate more complicated codes}

Besides simpel variables, you can also put chunk of code in the text, but you need to explicitely specify the return value of the chunk.
Following example is another way to contruct a HTML table in which eval rows and odd rows are assigned with different class names.

<<eval = TRUE, include = TRUE, echo = TRUE>>==
name = letters[1:4]
value = 1:4
str = qq("`
  text = character(length(name))
  for(i in seq_along(name)) {
    class = ifelse(i %% 2, 'odd', 'even')
      text[i] = qq(\"<tr class='@{class}'><td>@{name[i]}</td><td>@{value[i]}</td></tr>\n\")
  }
text
`", code.pattern = "`CODE`")
cat(str)
@

In above example, the string also contains a {\tt qq} function, so please use differnt code patterns for them.

\section{Simple template system}
More advanced, you can make a simple template system. E.g., put following code in {\tt template.html}

<<eval = TRUE, echo = FALSE, include = TRUE>>==
html = "<html>
<body>
<h2>Report for [% report_name %]</h2>
<table>
	<tr><th>name</th><th>value</th></tr>
[% 
text = character(length(name))
for(i in seq_along(name)) {
  class = ifelse(i %% 2, 'odd', 'even')
    text[i] = qq(\"<tr class='@{class}'><td>@{name[i]}</td><td>@{value[i]}</td></tr>\\n\")
}
paste(text, collapse = '')  # make sure this chunk only returns vector with length of 1.
%]
</table>
</body>
</html>
"
cat(html)
@

read {\tt template.html} and do the interpolation:
<<eval = FALSE, echo = TRUE>>==
template = paste(readLines("template.html"), collapse = "\n")

report_name = "test"
name = letters[1:4]
value = 1:4
html = qq(template, code.pattern = "\\[%CODE%\\]")
writeLines(html, file = "report.html")
@

You will get a report like:

<<eval = TRUE, echo = FALSE, include = TRUE>>==
report_name = "test"
name = letters[1:4]
value = 1:4
qqcat(html, code.pattern = "\\[%CODE%\\]")
@

\end{document}
